<?php

namespace AGIL\DefaultBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Tools\Pagination\Paginator;

/**
 * AgilTagRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AgilTagRepository extends EntityRepository
{
	/**
	 * @param $firstLetter String Le premier caractère du tag
	 * @return String Un texte en JSON avec la liste des tags correspondants
	 * Sert à trouver les tags dont la première lettre est $firstLetter
	 */
	function getTagsList($firstLetter) {
		// On créé la requête
		$request = $this->createQueryBuilder('t')->where('t.tagName LIKE :string')->setParameter('string', $firstLetter.'%');
		// On l'execute et on retourne le résultat
		/* /!\ C'est une liste d'objet de type AgilTag /!\ */
		return $request->getQuery()->getResult();
	}


	/**
	 * Recherche des sujets de forum par rapport à $arrayTag,
	 * trié par ordre de date décroissant, avec la méthode OR
	 * @param $arrayTag
	 * @return array
	 */
	public function getOrSubjectByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$query = $this->_em->createQueryBuilder();
		$subQuery = $this->_em->createQueryBuilder();

		$subQuery->select('subj.forumSubjectId')
				->distinct()
				->from('AGIL\ForumBundle\Entity\AgilForumSubject','subj')
				->leftJoin('subj.tags','tag')
				->andWhere('tag.tagName IN (:tagList)')
				->orderBy('subj.forumSubjectPostDate','desc')
		;

		$query->select('sub.forumSubjectId','sub.forumSubjectTitle','sub.forumSubjectPostDate','sub','cat.forumCategoryId','t')
				->from('AGIL\ForumBundle\Entity\AgilForumSubject','sub')
				->leftJoin('sub.category','cat')
				->leftJoin('sub.tags','t')
				->where($query->expr()->In('sub.forumSubjectId', $subQuery->getDQL()))
				->orderBy('sub.forumSubjectPostDate','desc')
		;

		$query->setParameter('tagList', $arrayTag);

		$completeResult = $query->getQuery()->getResult();

		// On retire les sujets qui possède au moins un tag appartenant à $arrayNo
		foreach($completeResult as $key => $res){
			foreach($res[0]->getTags() as $tag){
				if(in_array($tag->getTagName(),$arrayNo)){
					unset($completeResult[$key]);
				}
			}
		}

		// Gère la pagination
		$result = array_slice($completeResult,($page-1) * $maxperpage,$maxperpage);
		$countTotal = count($query->getQuery()->getResult());

		return array($result,$countTotal);

	}


	/**
	 * Recherche des sujets de forum par rapport à $arrayTag,
	 * trié par ordre de date décroissant, avec la méthode AND
	 * @param $arrayTag
	 * @return array
	 */
	public function getAndSubjectByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$subQuery = $this->_em->createQueryBuilder();
		$query = $this->_em->createQueryBuilder();

		$subQuery->select('subj.forumSubjectId')
				->from('AGIL\ForumBundle\Entity\AgilForumSubject','subj')
				->leftJoin('subj.tags','tag')
				->andWhere('tag.tagName IN (:tagList)')
				->groupBy('subj.forumSubjectId HAVING count(DISTINCT tag.tagName) >= :count')
		;

		$query->select('sub.forumSubjectId','sub.forumSubjectTitle','sub.forumSubjectPostDate','sub','cat.forumCategoryId')
				->from('AGIL\ForumBundle\Entity\AgilForumSubject','sub')
				->leftJoin('sub.category','cat')
				->where($query->expr()->In('sub.forumSubjectId', $subQuery->getDQL()))
				->orderBy('sub.forumSubjectPostDate','desc')
		;

		$query->setParameter('count', count($arrayTag));
		$query->setParameter('tagList', $arrayTag);


		$completeResult = $query->getQuery()->getResult();

		// On retire les sujets qui possède au moins un tag appartenant à $arrayNo
		foreach($completeResult as $key => $res){
			foreach($res[0]->getTags() as $tag){
				if(in_array($tag->getTagName(),$arrayNo)){
					unset($completeResult[$key]);
				}
			}
		}

		// Gère la pagination
		$result = array_slice($completeResult,($page-1) * $maxperpage,$maxperpage);
		$countTotal = count($query->getQuery()->getResult());

		return array($result,$countTotal);
	}


	/**
	 * Recherche des évènements du hall par rapport à $arrayTag,
	 * trié par ordre de date décroissant, avec la méthode OR
	 * @param $arrayTag
	 * @return array
	 */
	public function getOrEventByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$query = $this->_em->createQueryBuilder();
		$subQuery = $this->_em->createQueryBuilder();

		$subQuery->select('evt.eventId')
				->distinct()
				->from('AGIL\HallBundle\Entity\AgilEvent','evt')
				->leftJoin('evt.tags','tag')
				->andWhere('tag.tagName IN (:tagList)')
				->orderBy('evt.eventDate','desc')
		;

		$query->select('event.eventTitle','event.eventDate','event.eventId','event','t')
				->from('AGIL\HallBundle\Entity\AgilEvent','event')
				->leftJoin('event.tags','t')
				->where($query->expr()->In('event.eventId', $subQuery->getDQL()))
				->orderBy('event.eventDate','desc')
		;

		$query->setParameter('tagList', $arrayTag);

		$completeResult = $query->getQuery()->getResult();

		// On retire les évènements qui possède au moins un tag appartenant à $arrayNo
		foreach($completeResult as $key => $res){
			foreach($res[0]->getTags() as $tag){
				if(in_array($tag->getTagName(),$arrayNo)){
					unset($completeResult[$key]);
				}
			}
		}

		// Gère la pagination
		$result = array_slice($completeResult,($page-1) * $maxperpage,$maxperpage);
		$countTotal = count($query->getQuery()->getResult());

		return array($result,$countTotal);

	}

	/**
	 * Recherche des évènements du hall par rapport à $arrayTag,
	 * trié par ordre de date décroissant, avec la méthode AND
	 * @param $arrayTag
	 * @return array
	 */
	public function getAndEventByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$subQuery = $this->_em->createQueryBuilder();
		$query = $this->_em->createQueryBuilder();

		$subQuery->select('evt.eventId')
				->from('AGIL\HallBundle\Entity\AgilEvent','evt')
				->leftJoin('evt.tags','tag')
				->andWhere('tag.tagName IN (:tagList)')
				->groupBy('evt.eventId HAVING count(DISTINCT tag.tagName) >= :count')
		;

		$query->select('event.eventId','event.eventTitle','event.eventDate','event')
				->from('AGIL\HallBundle\Entity\AgilEvent','event')
				->where($query->expr()->In('event.eventId', $subQuery->getDQL()))
				->orderBy('event.eventDate','desc')
		;

		$query->setParameter('count', count($arrayTag));
		$query->setParameter('tagList', $arrayTag);

		$completeResult = $query->getQuery()->getResult();

		// On retire les sujets qui possède au moins un tag appartenant à $arrayNo
		foreach($completeResult as $key => $res){
			foreach($res[0]->getTags() as $tag){
				if(in_array($tag->getTagName(),$arrayNo)){
					unset($completeResult[$key]);
				}
			}
		}

		// Gère la pagination
		$result = array_slice($completeResult,($page-1) * $maxperpage,$maxperpage);
		$countTotal = count($query->getQuery()->getResult());

		return array($result,$countTotal);
	}


	/**
	 * Recherche des offres par rapport à $arrayTag,
	 * trié par ordre de date décroissant, avec la méthode OR
	 * @param $arrayTag
	 * @return array
	 */
	public function getOrOfferByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$query = $this->_em->createQueryBuilder();
		$subQuery = $this->_em->createQueryBuilder();

		$subQuery->select('off.offerId')
				->distinct()
				->from('AGIL\OfferBundle\Entity\AgilOffer','off')
				->leftJoin('off.tags','tag')
				->andWhere('tag.tagName IN (:tagList)')
				->orderBy('off.offerPostDate','desc')
		;

		$query->select('offer.offerTitle','offer.offerPostDate','offer.offerId','offer','t')
				->from('AGIL\OfferBundle\Entity\AgilOffer','offer')
				->leftJoin('offer.tags','t')
				->where($query->expr()->In('offer.offerId', $subQuery->getDQL()))
				->orderBy('offer.offerPostDate','desc')
		;

		$query->setParameter('tagList', $arrayTag);

		$completeResult = $query->getQuery()->getResult();

		// On retire les évènements qui possède au moins un tag appartenant à $arrayNo
		foreach($completeResult as $key => $res){
			foreach($res[0]->getTags() as $tag){
				if(in_array($tag->getTagName(),$arrayNo)){
					unset($completeResult[$key]);
				}
			}
		}

		// Gère la pagination
		$result = array_slice($completeResult,($page-1) * $maxperpage,$maxperpage);
		$countTotal = count($query->getQuery()->getResult());

		return array($result,$countTotal);

	}

	/**
	 * Recherche des offres par rapport à $arrayTag,
	 * trié par ordre de date décroissant, avec la méthode AND
	 * @param $arrayTag
	 * @return array
	 */
	public function getAndOfferByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$subQuery = $this->_em->createQueryBuilder();
		$query = $this->_em->createQueryBuilder();

		$subQuery->select('off.offerId')
				->from('AGIL\OfferBundle\Entity\AgilOffer','off')
				->leftJoin('off.tags','tag')
				->andWhere('tag.tagName IN (:tagList)')
				->groupBy('off.offerId HAVING count(DISTINCT tag.tagName) >= :count')
		;

		$query->select('offer.offerId','offer.offerTitle','offer.offerPostDate','offer')
				->from('AGIL\OfferBundle\Entity\AgilOffer','offer')
				->where($query->expr()->In('offer.offerId', $subQuery->getDQL()))
				->orderBy('offer.offerPostDate','desc')
		;

		$query->setParameter('count', count($arrayTag));
		$query->setParameter('tagList', $arrayTag);

		$completeResult = $query->getQuery()->getResult();

		// On retire les offres qui possède au moins un tag appartenant à $arrayNo
		foreach($completeResult as $key => $res){
			foreach($res[0]->getTags() as $tag){
				if(in_array($tag->getTagName(),$arrayNo)){
					unset($completeResult[$key]);
				}
			}
		}

		// Gère la pagination
		$result = array_slice($completeResult,($page-1) * $maxperpage,$maxperpage);
		$countTotal = count($query->getQuery()->getResult());

		return array($result,$countTotal);
	}



	/**
	 * Recherche des profils par rapport à $arrayTag,
	 * trié par skill maximum sur ces tags, avec la méthode AND
	 * @param $arrayTag
	 * @return array
	 */
	public function getAndProfileByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$query = $this->_em->createQueryBuilder();

		$query->select('user.id','user')
				->from('AGIL\UserBundle\Entity\AgilUser','user')
		;

		$completeResult = $query->getQuery()->getResult();
		$bestUser = null;

		foreach($completeResult as $key => $res){

			// On récupère tous les Skills associé au User
			$skills = $this->getEntityManager()->getRepository('AGILProfileBundle:AgilSkill')->findBy(array('user' => $res));

			// Pour chaque skill, on récupère les tagName
			$tagTab = array();
			foreach($skills as $s){
				$tagTab[] = $s->getTag()->getTagName();
			}

			// Si le user n'a pas tous les tags contenu dans $arrayTag,
			// ou si il possède un tag qui appartient à $arrayNo, on l'enlève
			if(array_diff($arrayTag,$tagTab) != null || !empty(array_intersect($arrayNo, $tagTab))){
				unset($completeResult[$key]);
			}else{
				// Sinon, on calcul son niveau pour les tags d'arrayTag
				$level = 0;
				foreach($skills as $s){
					if(in_array($s->getTag()->getTagName(),$arrayTag)){
						$level += $s->getSkillLevel();
					}
				}
				$bestUser[$res['id']] = $level;
			}

		}

		// Tri par rapport au niveau de skill
		if(count($bestUser) > 0){
			arsort($bestUser);

			$userSortedList[] = null;
			$i = 0;
			// On prend tous les Users dans l'ordre
			foreach($bestUser as $key => $res){
				$userSortedList[$i++] = $this->getEntityManager()->getRepository('AGILUserBundle:AgilUser')->find($key);
			}

			// Gère la pagination
			$result = array_slice($userSortedList,($page-1) * $maxperpage,$maxperpage);
			$countTotal = count($userSortedList);

			return array($result,$countTotal);
		}else{
			return array(array(),0);
		}

	}

	/**
	 * Recherche des profils par rapport à $arrayTag,
	 * trié par skill maximum sur ces tags, avec la méthode OR
	 * @param $arrayTag
	 * @param $arrayNo
	 * @param int $page
	 * @param int $maxperpage
	 * @return array
	 */
	public function getOrProfileByTags($arrayTag,$arrayNo,$page=1, $maxperpage=4){

		$query = $this->_em->createQueryBuilder();

		$query->select('user.id','user')
				->from('AGIL\UserBundle\Entity\AgilUser','user')
		;

		$completeResult = $query->getQuery()->getResult();
		$bestUser = null;

		foreach($completeResult as $key => $res){

			// On récupère tous les Skills associé au User
			$skillRepository = $this->getEntityManager()->getRepository('AGILProfileBundle:AgilSkill');
			$skills = $skillRepository->findBy(array('user' => $res));

			// Pour chaque skill, on récupère les tagName
			$tagTab = array();
			foreach($skills as $s){
				$tagTab[] = $s->getTag()->getTagName();
			}

			// Si le user n'a aucun des tags contenu dans $arrayTag,
			// ou si il possède un tag qui appartient à $arrayNo, on l'enlève
			if(empty(array_intersect($arrayTag,$tagTab)) || !empty(array_intersect($arrayNo, $tagTab))){
				unset($completeResult[$key]);
			}else{
				// Sinon, on calcul le niveau de son meilleur skill parmi les tags
				$levelMax = 0;
				foreach($skills as $s)
					if(in_array($s->getTag()->getTagName(),$arrayTag))
						if($s->getSkillLevel() > $levelMax)
							$levelMax = $s->getSkillLevel();
				$bestUser[$res['id']] = $levelMax;
			}

		}


		// Tri par rapport au niveau de skill
		if(count($bestUser) > 0){
			arsort($bestUser);

			$userSortedList[] = null;
			$i = 0;
			// On prend tous les Users dans l'ordre
			foreach($bestUser as $key => $res){
				$userSortedList[$i++] = $this->getEntityManager()->getRepository('AGILUserBundle:AgilUser')->find($key);
			}

			// Gère la pagination
			$result = array_slice($userSortedList,($page-1) * $maxperpage,$maxperpage);
			$countTotal = count($userSortedList);

			return array($result,$countTotal);
		}else{
			return array(array(),0);
		}

	}


}
